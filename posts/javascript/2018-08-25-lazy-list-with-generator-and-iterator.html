<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="keywords" content="Lazy List, Generator, Iterator">
        <meta name="description" content="在编程深入到一定领域的时候，惰性求值 (Lazy evaluation) 是绕不开的一部分。在现实中，有各种需求需要我们应对，为了防止可能的溢出情况，我们往往要凭借经验预先去定义一个上界或者下届，在绝大多数情况下，我们的操作是预先开辟大块内存以备不时之需，形成有意而为之的资源浪费。这种时候，引入惰性列表，或者惰性求值策略，可以在特定情况下帮我们节省资源开销，简化我们的复杂代码。本文主要讲述如何通过 ES6 的新特性 - Generator 和 Iterator，实现惰性列表功能。">
        <title>夜色残阳 | 博客 - 基于 Generator 和 Iterator 的惰性列表</title>
        <link rel="stylesheet" type="text/css" href="../../static_dist/css/default.css" />
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-122703565-1"></script>
        <script>
            if (document.URL.indexOf("wangqiao.me") >= 0) {
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', 'UA-122703565-1');
            }
        </script>
    </head>
    <body>
        <header class="header">
  <nav class="header__name">
      <a href="../../">夜色残阳の杂货铺子</a>
  </nav>
  <nav class="header__navigation">
      <a href="../../blog.html">Blog</a>
      <!-- <a href="/archive.html">Archive</a> -->
      <a href="../../about.html">About</a>
      <a href="https://github.com/nodew">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github">
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
      </a>
  </nav>
</header>

        <link rel="stylesheet" href="../../static_dist/lib/highlight/styles/github.css"></style>
<div class="content post">
  <h3 class="post-title">基于 Generator 和 Iterator 的惰性列表</h3>
  <div class="post-date">August 25, 2018</div>
  <div class="post-body">
    <h2 id="初识-lazy-list">初识 Lazy List</h2>
<p>如果有了解过 Haskell 的朋友，对下面的这些表达一定不陌生</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">repeat <span class="dv">1</span> <span class="co">-- =&gt; [1, 1, 1, 1, 1,...]</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">cycle <span class="st">&quot;abc&quot;</span> <span class="co">-- =&gt; &quot;abcabcabc...&quot;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">[<span class="dv">1</span>, <span class="dv">3</span><span class="fu">..</span>] <span class="co">-- =&gt; [1, 3, 5, 7, ...]</span></a></code></pre></div>
<p>上面的几个表达式产生的都是无限列表。对于习惯了主流编程语言的朋友可能感到困惑，在有限的内存里面如何能表达无限的概念。主要的原因就是 Haskell 是一门默认采用惰性求值策略的语言，没有用到的部分，在内存里面只是一个表达式，并不会真正的去做计算。</p>
<p>如果只看上面的几个表达式，很多朋友可能会说，也没感觉到有什么神奇的地方，似乎并没有什么作用。我们再看看下面的代码。</p>
<p>Haskell 中的 <code>fibonacci</code> 数列：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">fibonacci <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibonacci (tail fibonacci)</a></code></pre></div>
<p>这里 <code>fibonacci</code> 本身是一个惰性结构，所以在计算的时候，会先算出列表前面的两个1，得到 <code>1 : 1...</code> 这样的结构，然后怎么表达 <code>fibonacci</code> 的 <code>fib(n) = fib(n - 1) + fib(n - 2)</code> 特性呢？我们可以注意到，<code>n - 1</code>和 <code>n - 2</code> 刚好在数列中相差一位，所以 <code>n</code> 可以看作是该数列错位的相加的结果。</p>
<p>我们再来看一则<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">筛法求素数</a>。不熟悉筛法的可以先点开 wiki 去看一下该算法的思路。下面这段代码是 Haskell 的一个简单实现。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">primes <span class="fu">=</span> <span class="dv">2</span> <span class="fu">:</span> filter isPrime [<span class="dv">3</span>, <span class="dv">5</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    isPrime x <span class="fu">=</span> all (\p <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> p <span class="fu">&gt;</span> <span class="dv">0</span>) (takeWhile (\p <span class="ot">-&gt;</span> p <span class="fu">*</span> p <span class="fu">&lt;=</span> x) primes)</a></code></pre></div>
<h2 id="so-why-lazy">So, Why Lazy?</h2>
<p>在某些不定长度的列表操作上，惰性列表会让代码和结构更灵活。用上面的 <code>primes</code> 列表举个例子好了，在传统的 C 语言或者 Java 的实现里面，我们一般要先声明一个最大长度或者一个最大的取值范围，比如 10000 以内的素数。如果后面的计算要用到超过这个范围，我们就不得不重新调用生成函数，重新生成一份更长的列表。这里面的问题是：一、要主动去调用这个工厂函数，二、如果要复用已经计算出来的数据，手动去维护一个cache列表，势必增加代码的复杂度。另外一个可能的情况是，我们预先生成了一份很长的列表，后面的计算中只用到了列表头部的一丢丢数据，这也是极大的浪费。</p>
<p>惰性列表的使用增加了我们编程的表达能力，让我们可以更关注数据结构本身的特性，而不是浪费时间在如何去管理堆栈上面。因为，惰性求值特性保证我们在需要一个值的时候才会去计算，所以可以自动地最小化我们的计算量，节约资源。</p>
<p>比如我们可以通过 lazy byteString 去读、写文件，它本身不会把整个文件加载到我们的内存里面，而是按需的读取。有的时候我们读一个大文件，可能只筛选出需要的前几十条数据，却确不得不把几百 M 甚至上 G 的大文件整个的放到内存里面。</p>
<p>这里也找到一篇14年的文章 <a href="http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/">How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation</a>，感兴趣的可以点开看看。</p>
<h2 id="在-javascript-中实现-lazy-list">在 JavaScript 中实现 Lazy List</h2>
<p>在 JavaScript 有没有惰性结构呢？先看下面这个例子。</p>
<pre class="typescript"><code>let fetchSomething = fetch('/some/thing');
if (condition) {
  fetchSomething = fetch('/some/thing/condition');
}
fetchSomething.then(() =&gt; {
  // TODO
});</code></pre>
<p><code>fetch</code> 方法本身是立即执行的，如果满足条件，这里的 <code>fetch</code> 方法会执行两次。这并不是我们期待的行为，这里需要让这个 <code>fetch</code> 的动作在我们需要的时候才去执行，而不是声明的时候就开始执行的话，通常的做法是把它改成下面的样子。</p>
<pre class="typescript"><code>let fetchSomething = () =&gt; fetch('/some/thing');
if (condition) {
  fetchSomething = () = fetch('/some/thing/condition');
}
fetchSomething.then(() =&gt; {
  // TODO
});</code></pre>
<p>由此启发，我们大致可以实现如下的结构。</p>
<pre class="typescript"><code>class List&lt;T&gt; {
  head: T | () =&gt; T
  tail: List&lt;T&gt; | () =&gt; List&lt;T&gt;

  constructor(head: T, tail: () =&gt; List&lt;T&gt;) {
    this.head = () =&gt; head;
    this.tail = tail;
  }
}</code></pre>
<p><code>List&lt;T&gt;</code> 本质上是一个单链表，构造函数里面传入的 tail 是一个工厂函数，用来构建新的 List 节点。只有在我们访问到一个节点的时候，才对它的 head 求值，访问它的下一个节点的时候对 tail 求值，不然 head 和 tail 都只是待求值的表达式。</p>
<p>这种方式看起来似乎已经解决了我的问题，但是这种结构在和普通的 Array 做互相转换的时候，存在大量不必要的额外开销。</p>
<p>那 JavaScript 中有没有更天然的结构，可以让我们免于去构造这样一个复杂的对象，简化代码的同时，让我们的代码更具有普适性呢？</p>
<h3 id="初识-iterable">初识 Iterable</h3>
<p>ES6 的新特性给了我想要的答案，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration Protocols</a>。如果嫌MDN的描述太长，可以直接看下面等价的类型声明。</p>
<pre class="typescript"><code>interface Iterable&lt;T&gt; {
  [Symbol.iterator](): Iterator&lt;T&gt;;
}

interface Iterator&lt;T&gt; {
  next(): IteratorResult&lt;T&gt;;
}

interface IteratorResult&lt;T&gt; {
  done: Boolean;
  value?: T;
}

interface IterableIterator&lt;T&gt; {
  [Symbol.iterator](): Iterator&lt;T&gt;;
  next(): IteratorResult&lt;T&gt;;
}</code></pre>
<p>所有实现一个Iterable接口的对象都可以通过诸如 <code>for...of...</code>、<code>...itor</code> 以及 <code>Array.from</code> 来访问，当next方法的返回值中done为true时，迭代结束。而且只有我们访问next方法时，才会进入下一步迭代，是理想的Lazy结构。</p>
<p>这时候我们看一下我们的 fibonacci 该怎么写？</p>
<pre class="typescript"><code>class Fibonacci implements IterableIterator&lt;number&gt; {
  private prev = 1;
  private next = 1;

  public next() {
    let current = this.prev;
    this.prev = this.next;
    this.next = current + this.prev;
    return {
      done: false,
      value: current
    }
  }

  [Symbol.iterator]() {
    return this;
  }
}

const fib = new Fibonacci();
fib.next() // =&gt; { done: false, value: 1 }
fib.next() // =&gt; { done: false, value: 1 }
fib.next() // =&gt; { done: false, value: 2 }
// etc</code></pre>
<p>到这里，我们已经可以表达一个惰性的无限数列了。但是上面的代码毕竟过于繁琐，好在 ES6 同时给我们提供了 Generator, 可以让我们很方便地书写 IterableItorator，从某种意义上来讲，Generator 可以说是上面代码的语法糖。</p>
<p>使用Generator，上面的代码可以简化成下面的样子。</p>
<pre class="typescript"><code>export function* fibonacci() {
  let prev = 1;
  let next = 1;

  while (true) {
    yield prev;
    const temp = prev;
    prev = next;
    next = temp + prev;
  }
}

const fib = fibonacci();
// etc</code></pre>
<p>这里不再去花段落介绍 Generator 的语法，不了解的同学可以先去阅读下这篇文章 <a href="https://medium.com/dailyjs/a-simple-guide-to-understanding-javascript-es6-generators-d1c350551950">A Simple Guide to Understanding Javascript (ES6) Generators</a>。</p>
<h3 id="定义-infinite-list">定义 Infinite List</h3>
<p>接着上面的代码往下写，下面的代码分别实现了文章开头的 repeat, cycle, iterate, range 等方法。</p>
<pre class="typescript"><code>export function* repeat&lt;T&gt;(item: T) {
  while (true) {
    yield item;
  }
}

export function* cycle&lt;T&gt;(items: Iterable&lt;T&gt;) {
  while (true) {
    yield* [...items];
  }
}

export function* iterate&lt;T&gt;(fn: (value: T) =&gt; T, initial: T) {
  let val = initial;
  while (true) {
    yield val;
    val = fn(val);
  }
}

export function* range(start: number, end = Infinity, step = 1) {
  while (start &lt;= end) {
    yield start;
    start += step;
  }
}</code></pre>
<p>可以看到，代码是非常直观且易于理解的。</p>
<h3 id="定义-operator">定义 Operator</h3>
<p>有了列表之后，我们需要在列表之上进行操作，下面的代码分别实现了 map/filter/take/takeWhile 方法。</p>
<pre class="typescript"><code>export function* map&lt;T, U&gt;(fn: (value: T) =&gt; U, items: Iterable&lt;T&gt;) {
  for (let item of items) {
    yield fn(item);
  }
}

export function* filter&lt;T&gt;(
  predicate: (value: T) =&gt; boolean,
  items: Iterable&lt;T&gt;
) {
  for (let item of items) {
    if (predicate(item)) {
      yield item;
    }
  }
}

export function* take&lt;T&gt;(n: number, items: Iterable&lt;T&gt;) {
  let i = 0;
  if (n &lt; 1) return;

  for (let item of items) {
    yield item;
    i++;
    if (i &gt;= n) {
      return;
    }
  }
}

function* takeWhile&lt;T&gt;(
  predicate: (value: T) =&gt; boolean,
  items: Iterable&lt;T&gt;
) {
  for (let item of items) {
    if (predicate(item)) {
      yield item;
    } else {
      return;
    }
  }
}</code></pre>
<p>上面的代码都是比较简单的。比较难一点的是去实现 <code>zip</code> 方法，即怎么把两个列表合并成一个？</p>
<p>难点在于接收一个 Iterable 的对象的话，本身并不一定要实现 <code>next</code> 方法的，比如 Array、String 等，同时Iterable对象也并不是都可以通过 index 来访问的。此外，如果想先通过Array.from变成数组，然后在数组上进行操作，我们会遇到一个情况是我们传入的 Iterable 对象是无限的，如上文的 fibonacci 一样，这种情况下是不能使用 Array.from 的。</p>
<p>这时候我的一个思路是需要想办法把一个 Iterable 的对象提升成为 IterableItorator 对象，然后通过 next 方法，逐一遍历。</p>
<p>How ？幸好 Generator 给我们提供了一个 <code>yield*</code> 操作符，可以让我们方便的定义出一个 <code>lift</code> 方法。</p>
<pre class="typescript"><code>export function* lift&lt;T&gt;(items: Iterable&lt;T&gt;): IterableIterator&lt;T&gt; {
  yield* items;
}</code></pre>
<p>有了这个 <code>lift</code> 方法之后，就可以很方便的书写 <code>zip</code> 方法和 <code>zipWith</code> 方法了。</p>
<pre class="typescript"><code>export function* zip&lt;T, G&gt;(
  seqA: Iterable&lt;T&gt;,
  seqB: Iterable&lt;G&gt;
): IterableIterator&lt;[T, G]&gt; {
  const itorA = lift(seqA);
  const itorB = lift(seqB);
  let valA = itorA.next();
  let valB = itorB.next();
  while (!valA.done || !valB.done) {
    yield [valA.value, valB.value];
    valA = itorA.next();
    valB = itorB.next();
  }
}

export function* zipWith&lt;T, G, R&gt;(
  fn: (a: T, b: G) =&gt; R,
  seqA: Iterable&lt;T&gt;,
  seqB: Iterable&lt;G&gt;
): IterableIterator&lt;R&gt; {
  const itorA = lift(seqA);
  const itorB = lift(seqB);
  let valA = itorA.next();
  let valB = itorB.next();
  while (!valA.done || !valB.done) {
    yield fn(valA.value, valB.value);
    valA = itorA.next();
    valB = itorB.next();
  }
}</code></pre>
<p>更多的方法可以去底部的点开我的 repo，这里就不一一列举了。</p>
<h2 id="结语">结语</h2>
<p>Generator 和 Iterator 是 ES6 带给我们的非常强大的语言层面的能力，它本身的求值可以看作是惰性的。</p>
<p>差不多在13年左右，TJ 的 <a href="https://github.com/tj/co">co</a> 刚出来的时候，其代码的短小精悍可以说是相当惊艳的。然而在我们的使用中，一来受限于浏览器兼容性，二来受限于我们的使用场景，个人认为我们对其特性开发得还远远不够。结合 IO、network，Generator 和 Iterator 还能为我们做更多的事情。</p>
<p>另外，需要特别说明的是，虽然这篇文章通篇是在讲惰性列表，但是惰性列表并不是银弹，相反的，惰性结构的滥用会在程序的执行过程中缓存大量的thunk，增大在内存上的开销。</p>
<p>完整代码请移步 <a href="https://github.com/nodew/lazyList">GitHub</a>。</p>
<p>本文首发于<a href="https://tech.youzan.com/lazy-list-with-generator-and-iterator/">有赞技术博客</a>。</p>
  </div>
  <div id="comments"></div>
</div>
<script src="../../static_dist/lib/highlight/highlight.pack.js"></script>
<script>
hljs.configure({
  tabReplace: '    ',
});
hljs.initHighlighting();
</script>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var matches = location.pathname.match(/^\/posts\/(.+)\.html/);
var match = matches[1];
var id = match.replace(/\d{4}-\d{2}-\d{2}-/, '');
var gitment = new Gitment({
  title: "基于 Generator 和 Iterator 的惰性列表",
  id: id,
  owner: 'nodew',
  repo: 'blog',
  oauth: {
    client_id: '3f36214bd191119338cc',
    client_secret: '8527738f4cbb1a4b916c87d8573d57c9c4e57413',
  },
});
gitment.render('comments')
</script>

        <footer class="footer">
  <div class="copyright">Copyright © 2017-2018 WANGQIAO.ME. All rights reserved.</div>
  <div class="hakyll">
    Site generated by
    <a href="https://jaspervdj.be/hakyll/">Hakyll</a>
  </div>
</footer>
    </body>
    <script src="../../static_dist/js/index.js"></script>
</html>
